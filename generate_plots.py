# PLOTS EXPLANATION:
#
#   Plot 1: MT25081_cpu_vs_components.png
#   ├─ Purpose: Show CPU utilization scaling for CPU-bound workload on a single core.
#   ├─ X-axis: Scale (Number of processes/threads)
#   ├─ Y-axis: CPU Utilization (%)
#   ├─ Line 1: progA (processes) - CPU% showing contention on one core.
#   ├─ Line 2: progB (threads) - CPU% showing thread performance on one core.
#   └─ Insight: Shows how processes vs threads compete for a single CPU resource.
#
#   Plot 2: MT25081_mem_vs_components.png
#   ├─ Purpose: Show memory usage scaling for memory-bound workload.
#   ├─ X-axis: Scale (Number of processes/threads)
#   ├─ Y-axis: Memory Usage (KB)
#   ├─ Line 1: progA (processes) - Memory usage should increase with each new process.
#   ├─ Line 2: progB (threads) - Memory usage should be relatively flat, showing memory sharing.
#   └─ Insight: Compares the memory footprint of isolated processes vs shared-memory threads.
#
#   Plot 3: MT25081_io_vs_components.png
#   ├─ Purpose: Show I/O scaling for I/O-bound workload.
#   ├─ X-axis: Scale (Number of processes/threads)
#   ├─ Y-axis: Total I/O (KB)
#   ├─ Line 1: progA (processes) - Shows I/O generated by concurrent processes.
#   ├─ Line 2: progB (threads) - Shows I/O generated by concurrent threads.
#   └─ Insight: Compares the I/O throughput of processes vs threads.
#
#   Plot 4: MT25081_time_vs_components.png
#   ├─ Purpose: Compare execution times across all worker types.
#   ├─ Contains: 3 subplots (one for each worker type).
#   └─ Insight: Shows how execution time varies with scale and concurrency model.
#

# INTERPRETATION GUIDE:
#   1. Steep line = High resource usage or good scaling, depending on the metric.
#   2. Flat line = Constant resource usage or poor scaling.
#   3. Intersecting lines = Crossover point where one model becomes more efficient.
#

# Import required libraries
import pandas as pd                # For reading CSV and data manipulation
import matplotlib.pyplot as plt    # For plotting and visualization
import sys                         # For system exit on errors
from pathlib import Path           # For file path operations
import numpy as np                 # For numerical operations

def main():
    """
    Main function to read CSV and generate all 4 plots.
    """
    
    # ====== PHASE 1: FILE VALIDATION ======
    # Define CSV filename
    csv_file = "MT25081_Part_D_CSV.csv"
    
    # Check if CSV file exists before attempting to read
    if not Path(csv_file).exists():
        print(f"Error: {csv_file} not found")
        print("Please run Part D benchmark first: bash MT25081_Part_D_scaling.sh")
        sys.exit(1)
    
    # ====== PHASE 2: READ CSV DATA ======
    # Read CSV file into pandas DataFrame for easy manipulation
    print("Reading benchmark data...")
    try:
        df = pd.read_csv(csv_file)
    except Exception as e:
        print(f"Error reading CSV: {e}")
        sys.exit(1)
    
    # Validate that required columns exist (updated for new format)
    required_columns = ['Program', 'Worker_Type', 'Scale', 'AvgCPU_Percent', 
                        'AvgMemory_KB', 'TotalIO_KB', 'ExecutionTime_Sec']
    if not all(col in df.columns for col in required_columns):
        print(f"Error: CSV missing required columns. Expected: {required_columns}")
        sys.exit(1)
    
    # Print data summary
    print(f"  Loaded {len(df)} data rows")
    print(f"  Programs: {df['Program'].unique()}")
    print(f"  Worker types: {df['Worker_Type'].unique()}")
    print(f"  Scales: {sorted(df['Scale'].unique())}")
    print("")
    
    # ====== PHASE 3: CONFIGURE PLOTTING ======
    # Set matplotlib style for professional appearance
    plt.style.use('seaborn-v0_8-darkgrid')
    
    # Standard figure size for main plots
    fig_size = (14, 8)
    
    # ====== PHASE 4: PLOT 1 - CPU UTILIZATION (CPU WORKER) ======
    # Purpose: Analyze how CPU utilization scales for a CPU-bound workload
    #          when all processes/threads are pinned to a single core.
    #
    print("Generating performance analysis plots...")
    
    # Create figure and axis for plot 1
    fig, ax = plt.subplots(figsize=fig_size)
    
    # Extract CPU worker data only
    cpu_data = df[df['Worker_Type'] == 'cpu']
    
    # Separate by program and sort by scale
    progA_cpu = cpu_data[cpu_data['Program'] == 'progA'].sort_values('Scale')
    progB_cpu = cpu_data[cpu_data['Program'] == 'progB'].sort_values('Scale')
    
    # Plot line for progA (processes)
    ax.plot(progA_cpu['Scale'], progA_cpu['AvgCPU_Percent'], 
            marker='o', label='Program A (Processes)', 
            linewidth=2.5, markersize=8, color='#2E86AB')
    
    # Plot line for progB (threads)
    ax.plot(progB_cpu['Scale'], progB_cpu['AvgCPU_Percent'], 
            marker='s', label='Program B (Threads)', 
            linewidth=2.5, markersize=8, color='#A23B72')
    
    # Configure axes labels and title
    ax.set_xlabel('Scale (Count)', fontsize=12, fontweight='bold')
    ax.set_ylabel('CPU Utilization (%)', fontsize=12, fontweight='bold')
    ax.set_title('CPU Utilization vs Scale - CPU Worker', 
                 fontsize=14, fontweight='bold')
    
    # Add legend and grid
    ax.legend(fontsize=11, loc='best')
    ax.grid(True, alpha=0.3)
    
    # Save high-resolution PNG
    plt.tight_layout()
    plt.savefig('MT25081_cpu_vs_components.png', dpi=300, bbox_inches='tight')
    print("  Generated: MT25081_cpu_vs_components.png")
    plt.close()
    
    # ====== PHASE 5: PLOT 2 - MEMORY USAGE (MEMORY WORKER) ======
    # Purpose: Analyze how memory usage (in KB) scales for a memory-bound workload.
    #
    
    fig, ax = plt.subplots(figsize=fig_size)
    
    # Extract memory worker data only
    mem_data = df[df['Worker_Type'] == 'mem']
    
    # Separate by program and sort by scale
    progA_mem = mem_data[mem_data['Program'] == 'progA'].sort_values('Scale')
    progB_mem = mem_data[mem_data['Program'] == 'progB'].sort_values('Scale')
    
    # Plot lines using the new AvgMemory_KB column. This shows absolute memory usage.
    ax.plot(progA_mem['Scale'], progA_mem['AvgMemory_KB'], 
            marker='o', label='Program A (Processes)', 
            linewidth=2.5, markersize=8, color='#2E86AB')
    ax.plot(progB_mem['Scale'], progB_mem['AvgMemory_KB'], 
            marker='s', label='Program B (Threads)', 
            linewidth=2.5, markersize=8, color='#A23B72')
    
    # Configure axes with updated labels
    ax.set_xlabel('Scale (Count)', fontsize=12, fontweight='bold')
    ax.set_ylabel('Memory Usage (KB)', fontsize=12, fontweight='bold')
    ax.set_title('Memory Usage vs Scale - Memory Worker', 
                 fontsize=14, fontweight='bold')
    ax.legend(fontsize=11, loc='best')
    ax.grid(True, alpha=0.3)
    
    # Save
    plt.tight_layout()
    plt.savefig('MT25081_mem_vs_components.png', dpi=300, bbox_inches='tight')
    print("  Generated: MT25081_mem_vs_components.png")
    plt.close()
    
    # ====== PHASE 6: PLOT 3 - TOTAL I/O (I/O WORKER) ======
    # Purpose: Analyze how total I/O (in KB) scales for an I/O-bound workload.
    #
    
    fig, ax = plt.subplots(figsize=fig_size)
    
    # Extract I/O worker data
    io_data = df[df['Worker_Type'] == 'io']
    
    # Separate by program and sort by scale
    progA_io = io_data[io_data['Program'] == 'progA'].sort_values('Scale')
    progB_io = io_data[io_data['Program'] == 'progB'].sort_values('Scale')
    
    # Plot lines using the new TotalIO_KB column. This shows total kilobytes written.
    ax.plot(progA_io['Scale'], progA_io['TotalIO_KB'], 
            marker='o', label='Program A (Processes)', 
            linewidth=2.5, markersize=8, color='#2E86AB')
    ax.plot(progB_io['Scale'], progB_io['TotalIO_KB'], 
            marker='s', label='Program B (Threads)', 
            linewidth=2.5, markersize=8, color='#A23B72')
    
    # Configure axes with updated labels
    ax.set_xlabel('Scale (Count)', fontsize=12, fontweight='bold')
    ax.set_ylabel('Total I/O (KB)', fontsize=12, fontweight='bold')
    ax.set_title('Total I/O vs Scale - I/O Worker', 
                 fontsize=14, fontweight='bold')
    ax.legend(fontsize=11, loc='best')
    ax.grid(True, alpha=0.3)
    
    # Save
    plt.tight_layout()
    plt.savefig('MT25081_io_vs_components.png', dpi=300, bbox_inches='tight')
    print("  Generated: MT25081_io_vs_components.png")
    plt.close()
    
    # ====== PHASE 7: PLOT 4 - EXECUTION TIME (ALL WORKER TYPES) ======
    # Purpose: Compare execution time scaling for all three worker types.
    #
    
    fig, axes = plt.subplots(1, 3, figsize=(18, 5))
    
    # Iterate through each worker type
    for idx, worker in enumerate(['cpu', 'mem', 'io']):
        ax = axes[idx]
        
        # Extract data for this worker type
        progA_subset = df[(df['Program'] == 'progA') & 
                          (df['Worker_Type'] == worker)].sort_values('Scale')
        progB_subset = df[(df['Program'] == 'progB') & 
                          (df['Worker_Type'] == worker)].sort_values('Scale')
        
        # Plot execution time for progA
        ax.plot(progA_subset['Scale'], progA_subset['ExecutionTime_Sec'], 
                marker='o', label='Processes', 
                linewidth=2.5, markersize=8, color='#2E86AB')
        
        # Plot execution time for progB
        ax.plot(progB_subset['Scale'], progB_subset['ExecutionTime_Sec'], 
                marker='s', label='Threads', 
                linewidth=2.5, markersize=8, color='#A23B72')
        
        # Configure this subplot
        ax.set_xlabel('Scale', fontsize=11, fontweight='bold')
        ax.set_ylabel('Time (seconds)', fontsize=11, fontweight='bold')
        ax.set_title(f'Execution Time - {worker.upper()} Worker', 
                     fontsize=12, fontweight='bold')
        ax.legend(fontsize=10, loc='best')
        ax.grid(True, alpha=0.3)
    
    # Save all 3 subplots as single figure
    plt.tight_layout()
    plt.savefig('MT25081_time_vs_components.png', dpi=300, bbox_inches='tight')
    print("  Generated: MT25081_time_vs_components.png")
    plt.close()
    
    # ====== PHASE 8: COMPLETION MESSAGE ======
    print("")
    print("All 4 plots generated successfully!")
    print("")
    print("Plot Files:")
    print("  1. MT25081_cpu_vs_components.png  (CPU utilization scaling)")
    print("  2. MT25081_mem_vs_components.png  (Memory usage scaling)")
    print("  3. MT25081_io_vs_components.png   (Total I/O scaling)")
    print("  4. MT25081_time_vs_components.png (Execution time comparison)")
    print("")
    print("Next Steps:")
    print("  1. Open plots to verify data visualization")
    print("  2. Analyze trends and identify optimal scale for each workload")
    print("  3. Include plots in PA01 report")
    print("")

# ============================================================================
# SCRIPT ENTRY POINT
# ============================================================================
# This is executed when script is run directly (not imported)

if __name__ == '__main__':
    main()



